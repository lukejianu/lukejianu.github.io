<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta name="google-site-verification" content="uBlVSjYSITD7PlZLCLEyJJFbHt6kmFbR_jocCAVjfa4"/>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Charis+SIL:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <link rel="canonical" href="https://lukejianu.github.io/blog/side-effects-in-haskell" />
    <title>Luke Jianu</title>
    <link rel="stylesheet" type="text/css" href="/styles.css" />
    <link rel="stylesheet" href="/highlight/styles/default.css">
    <script src="/highlight/highlight.js"></script>
    <script>hljs.highlightAll();</script>
  </head>
  <body>
    <root><div><style>body {
          max-width: 620px;
        }</style><style>@media screen and (max-width: 620px) {
           body {
             max-width: 95%;
           }
         }</style></div><h2 id="side-effects-in-haskell">Side Effects in Haskell</h2><h3 id="side-effects--interactive-programs">Side Effects &amp; Interactive Programs</h3><p>In math, a function accepts an input and produces an output. In programming, a function can additionally perform a <em>side effect</em>.</p><pre class="brush: C"><code>int foo(int x) {
  char c = getchar();
  return x + 1;
}</code></pre><p>We call this a side effect because the main purpose of a function is to produce an output—prompting the user for input is an effect that happens &ldquo;on the side&rdquo;.</p><p>Without side effects, we are limited to <em>batch programs</em>. A batch program behaves like a math function—accepting an input, computing, and producing an output. It is like a black box in the sense that it cannot interact/communicate with the outside world while it is computing. Its only form of interaction is accepting the input &ldquo;in a batch&rdquo; and producing an output &ldquo;in a batch&rdquo; (hence the name). An example of a batch program is a compiler, which accepts a program and produces a program.</p><p><em>Interactive programs</em> are more common today. Consider the browser program, which in some sense accepts no inputs and produces no outputs. Instead, it performs all kinds of side effects—reading keyboard and mouse input from the user, sending and receiving messages over the network, and displaying results on a screen.</p><h3 id="state-of-the-world">State of the World</h3><p>In Haskell, functions behave like they do in math. Despite this, Haskell functions can still perform side effects. Recall the earlier definition of a side effect: an effect the function performs outside of producing the output. Well, what if we make the output of a side effect performing function <strong>really big</strong>, so that there exists nothing &ldquo;outside of performing the output&rdquo;?. In Haskell, we call this output &ldquo;the state of the world&rdquo;, represented by the type <code>World</code>. Conceptually, you can think of this as a piece of data that represents the exact state of the universe at a particular instance in time.</p><p>As a first attempt, we can imagine that our <code>foo</code> function from above would have the signature <code>Int -&gt; (Int, World)</code>. It accepts an integer <code>x</code> and produces <code>x + 1</code> and some new <code>World</code> that captures the fact that the computer running the program is now waiting to read a character.</p><p>The problem with this first attempt is that we don&rsquo;t really want to create a new <code>World</code> from scratch. Instead, we just want to make a slight modification to the &ldquo;current&rdquo; <code>World</code>. Now, we could modify <code>foo</code> to accept the current <code>World</code> like so: <code>World -&gt; Int -&gt; (Int, World)</code>. This could work, but it&rsquo;s not ergonomic. This design would force programmers to pass the <code>World</code> around in their programs.</p><p>The approach Haskell takes is <code>Int -&gt; World -&gt; (Int, World)</code>. That is, the <code>foo</code> function produces a function <code>World -&gt; (Int, World)</code> that describes how the world changes. More generally, a function that performs a side effect always outputs <code>World -&gt; (a, World)</code> for some type <code>a</code>. We give this side effect output type a name: <code>IO</code>.</p><pre class="brush: haskell"><code>type IO a = World -&gt; (a, World)</code></pre><p>Putting everything together, <code>foo</code> has the signature <code>Int -&gt; IO Int</code>.</p><h3 id="review">Review</h3><p>It&rsquo;s worth taking some time to review what we just did here. We said that Haskell functions can perform side effects but then showed that they aren&rsquo;t side effects because of the <code>IO</code> type. So, which one is it?</p><p>I think the problem here is that terms like &ldquo;side effect&rdquo; and &ldquo;pure&rdquo; have different meanings. Others have discussed this same &ldquo;contradiction&rdquo; on the Haskell forums: <a href="https://discourse.haskell.org/t/should-haskell-be-rebranded-away-from-pure-functional-programming/4850">Should Haskell be rebranded away from &ldquo;Pure Functional Programming&rdquo;</a>.</p><p>A clearer way of phrasing the key takeaway is that Haskell supports interactive programming and encodes actions that we consider side effects in other languages inside the <code>IO</code> type. The explicit distinction between functions that produce <code>IO</code> values and functions that don&rsquo;t makes it easier to reason about code for humans and for the compiler, which makes Haskell a pleasant and efficient language to program in.</p></root>
    <hr/>
    <footer>
      Built with <a href="https://docs.racket-lang.org/pollen/" target="_blank">Pollen</a> &
      <a href="https://racket-lang.org/" target="_blank">Racket</a>.
    </footer>
  </body>
</html>