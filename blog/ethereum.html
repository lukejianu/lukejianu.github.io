<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta name="google-site-verification" content="uBlVSjYSITD7PlZLCLEyJJFbHt6kmFbR_jocCAVjfa4"/>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Charis+SIL:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <title>Luke Jianu</title>
    <link rel="stylesheet" type="text/css" href="/styles.css" />
    <link rel="stylesheet" href="/highlight/styles/default.css">
    <script src="/highlight/highlight.js"></script>
    <script>hljs.highlightAll();</script>
  </head>
  <body>
    <root><div><style>body {
          max-width: 620px;
        }</style><style>@media screen and (max-width: 620px) {
           body {
             max-width: 95%;
           }
         }</style></div><p><style>h2{  font-size: 1.45em; }</style></p><h2 id="ethereum-the-decentralized-computer">Ethereum: The Decentralized Computer</h2><blockquote><p>&ldquo;I happily played World of Warcraft during 2007&ndash;2010, but one day Blizzard removed the damage component from my beloved warlock’s Siphon Life spell. I cried myself to sleep, and on that day I realized what horrors centralized services can bring. I soon decided to quit.&rdquo; - Vitalik Buterin</p></blockquote><h3 id="bitcoin">Bitcoin</h3><h4 id="the-idea">The Idea</h4><p>Bitcoin is a ledger: an ordered list of transactions.</p><pre><code>Ledger

1. Alice sent Bob 2 coins    - Signed by Alice.
2. Bob sent Charlie 4 coins  - Signed by Bob.
3. Charlie sent Alice 1 coin - Signed by Charlie.</code></pre><p>The ledger represents the balances of each person, which one can easily compute by iterating over the transactions and tracking the movement of coins. Of course, in the example above, Alice and Bob end up with negative balances (debt), which we probably don&rsquo;t want to allow. We&rsquo;ll return to this later. An interesting observation here is that this ledger is its own <em>currency</em>. That is, if everyone used this same ledger, we wouldn&rsquo;t need dollars anymore.</p><p>Bitcoin&rsquo;s important property is that it is a <em>decentralized ledger</em>, which means that the ledger is not controlled or managed by a particular entity. This immediately raises questions. Who keeps track of the state of the ledger? Who decides how the ledger is updated?</p><p>In order for this ledger to be useful, there needs to be consensus on its state. Without a single source of truth, how could a seller trust that the buyer&rsquo;s transaction is set in stone?</p><p>Governments use voting to reach consensus on policy. Could we have everyone vote on what the state of the ledger should be? The proposed ledger with the most votes becomes the new ledger. This seems decentralized—anyone is allowed to propose a new ledger and vote, which means that no entity controls the ledger. It&rsquo;s the majority that controls the ledger, which is exactly what we want.</p><p>Recall, however, that an important part of voting is identity verification: every person is only allowed to vote once. Our voting system is vulnerable to Sybil attacks, in which an attacker creates many identities to gain more influence in the vote. A minority of bad actors could overwhelm the majority, and we lose the decentralized property.</p><p>Bitcoin uses a very clever voting mechanism. Your voting power increases based on your computing power. This way, the only way for an entity to control the ledger is to own the majority of compute, which would be extremely expensive. The way it works is that all members are always racing to solve a computationally difficult math puzzle. The members with more compute are more likely to solve the puzzle. When a member solves it, they gain the right to propose a new ledger. The ledger contains a stamp with the solution they found, so that others can quickly verify that they solved the puzzle. This stamp is known as the <em>proof of work</em>.</p><p>Of course, the new proposed ledger must be valid. It should only add new transactions to the ledger (as opposed to changing or removing old transactions), and they should all have valid digital signatures. The proposed ledger should also not represent any negative balances—you can&rsquo;t spend what you don&rsquo;t have. Even with a valid proof of work, the other members will ignore the proposed ledger if it isn&rsquo;t valid.</p><p>The proposer expended resources in the form of computation to solve the puzzle. This is an important job that needs to be performed in order to keep the ledger secure and growing. Thus, the proposer is rewarded for solving the puzzle. They reward themselves by adding a transaction to the proposed ledger granting themselves a few coins. This is how new coins are created (think back to how this solves the negative balance problem mentioned before).</p><p>Another way to think about Bitcoin is as a decentralized database. The database stores the balances of each member and supports operations to update the balances (transactions). It&rsquo;s decentralized because anyone can read and/or update the database according to the rules—there is no single entity that controls it.</p><p>More generally, a decentralized database tracks some state and allows certain state transitions. The Bitcoin currency is one application of the decentralized database technology. Namecoin is another: it&rsquo;s an implementation of decentralized DNS inspired by Bitcoin. Namecoin&rsquo;s state is a map from domain to IP address. Members exchange messages expressing how they would like the state to transition (create new domain, update old domain, etc.).</p><h4 id="the-implementation">The Implementation</h4><p>Technically, Bitcoin is a P2P network. There are two kinds of nodes: standard nodes and miners. A standard node keeps track of the ledger and broadcasts transactions it wants to make to the rest of the network. A miner collects transactions and proposes a new ledger whenever it solves a puzzle.</p><p>The ledger is represented as a chain of blocks (blockchain). A block contains a reference (hash) to the previous block, a list of transactions, and a number representing the proof of work. The math puzzle the miner is solving is simply searching for a number such that the hash of the entire block is smaller than a certain difficulty target. Once it finds the valid number, it broadcasts the block across the network.</p><p>It&rsquo;s possible for the blockchain to branch. That is, two different, valid blocks are broadcast across the network, where both blocks point to the same parent. This doesn&rsquo;t necessarily indicate malicious behavior—both miners might have solved puzzles at the same time. What should the other nodes do? Which chain should the miners work on (which hash should their new block point to)? Which chain should standard nodes rely on as the truth?</p><p>The miners, if they are smart, will work on the chain that is longer. This is because the longer chain is more likely to have more miners working on it. It&rsquo;s important to understand that miners don&rsquo;t receive a reward for solving the puzzle or even broadcasting a valid block—they only receive the rewards if their block becomes part of the chain that everyone else agrees is valid. Thus, the miners are also incentivized to publish valid blocks, since the other nodes will only accept the block if it represents a valid ledger transition.</p><p>Similarly, the standard nodes should also rely on the longer chain, because the majority of compute is likely working on that chain. On the Bitcoin network, it is very difficult for any one entity to create 7 blocks in a row. Thus, standard nodes wait until their relevant transaction is buried in at least 7 blocks before treating it as the source of truth.</p><h3 id="ethereum">Ethereum</h3><h4 id="the-idea">The Idea</h4><p>Ethereum is a general-purpose blockchain. That is, you can implement Bitcoin and Namecoin, or any other application that acts like a decentralized database on top of Ethereum.</p><p>Let&rsquo;s start by understanding Ethereum&rsquo;s state and transitions. Since Ethereum has its own currency called Ether, its state and transitions are a superset of Bitcoin&rsquo;s. That is, its state has a mapping from ID to balance and there are transactions that allow nodes to transfer Ether.</p><p>The genius of Ethereum is how it achieves its generality: storing entire applications inside the state and allowing nodes to send transactions to applications to interact with them.</p><p>Firstly, how do you store an application on the blockchain? Simply store the application&rsquo;s code and its current internal state (whatever it needs to remember in between calls). For example, we could store Twitter on the blockchain. Twitter&rsquo;s internal state is all the tweets/profiles. The code is Twitter&rsquo;s codebase, which defines what it means to make a new tweet or like a post (i.e., how the state should change).</p><p>A node can then send a transaction to an application containing an arbitrary message describing its request. In response, the application updates its internal state. Ethereum refers to these applications as <em>smart contracts</em>.</p><p>Consider a counter application. We first create the contract by broadcasting a transaction with its code and initial internal state. The counter&rsquo;s internal state starts at 0. The code describes the behavior—increment the state by 1 in response to a message. The contract is added to the blockchain when a miner includes the transaction in a block, effectively updating the state to include this new application.</p><p>When a node broadcasts a transaction targeting the counter contract, a miner picks up that transaction, and updates the blockchain state by running the contract&rsquo;s code. Now, the blockchain stores an updated version of the counter, with its count (state) incremented by 1.</p><p>Just like in Bitcoin, all nodes are required to check the validity of blocks for themselves. Since the state can transform in arbitrary ways based on the contract&rsquo;s code, all nodes must run the contract for themselves to determine the new state of the chain.</p><p>Ethereum is a <em>decentralized computer</em>. Users create applications and can run them on the Ethereum computer, taking advantage of its decentralization.</p><h4 id="aside-proof-of-stake">Aside: Proof of Stake</h4><p>Proof of Stake is an alternative consensus mechanism. In Proof of Work, a node&rsquo;s voting power increases based on their computing power. In Proof of Stake, a node&rsquo;s voting power increases based on the amount of Ether they own (their &ldquo;stake&rdquo;). In both systems, acquiring voting power requires expending resources, making it difficult for one entity to acquire a majority. In addition, there are clever mechanisms leveraging smart contracts that automatically destroy the Ether of nodes who break the rules.</p><p>In 2022, Ethereum switched from PoW to PoS, reducing the chain&rsquo;s energy usage by over 99%. In Ethereum PoS, nodes sign up to become validators by locking (staking) at least 32 ETH in a special smart contract. Every 12 seconds, a validator is randomly chosen to propose the new block—validators with more ETH staked have a higher chance of being chosen.</p></root>
    <hr/>
    <footer>
      Built with <a href="https://docs.racket-lang.org/pollen/" target="_blank">Pollen</a> &
      <a href="https://racket-lang.org/" target="_blank">Racket</a>.
    </footer>
  </body>
</html>